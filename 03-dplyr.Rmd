# Dplyr

```{r message=F}
library(tidyverse)
library(magrittr)
```

## Ressources

## What is `tidy-select`

- [Official docs here](https://dplyr.tidyverse.org/reference/select.html)

- In the end you always want a boolean vector  that has the length of the number of columns

## Selecting columns

### Selecting columns based on regex

- [Look here](https://tidyselect.r-lib.org/reference/starts_with.html) for all the possible helper functions.

- If you wanna apply a regex yourself you can use the `matches`-function. However there are "helpers" e.g. `starts_with`...

```{r select_regex}

# select all columns with three characters
mtcars %>% 
  select(
    matches("^[a-zA-Z]{3}$")
  )

# cant use logical vector is select (e.g select(mtcars, c(TRUE, FALSE))) does not work
# Must be indexes!
mtcars %>% 
  select(
      which(grepl("^[a-zA-Z]{3}$", names(.)))
  )

# select_if can use a boolean vector!! However is superseeded
mtcars %>% 
  select_if(
      grepl("^[a-zA-Z]{3}$", names(.))
  )


# do the same in base r
idx = grepl("^[a-zA-Z]{3}$", names(mtcars))
mtcars[, idx]

```


### Selecting Columns based if any value in the column is `na`


**Approach 1**

> select(where(function(x){
    mean(x) > ...
}))


```{r}
mtcars_copy = mtcars
mtcars_copy[2,2] = NA
mtcars_copy %>% head

# 1. 
mtcars_copy %>%
  select(where(function(x) {
    sum(is.na(x)) == 0
  }))

# 2. base r
mtcars_copy[, colSums(is.na(mtcars_copy)) == 0]

# 3. apply
mtcars_copy[, apply(mtcars_copy, 2, function(x) sum(is.na(x)) == 0)]

# using any
mtcars_copy[, apply(mtcars_copy, 2, function(x) !any(is.na(x)))]

```

### Selecting Columns if the mean is > ...

```{r}
# add a string column
mtcars["string"] = "a"

# select only string columns or numeric ones with a mean > 10

# Should both work!!

# mtcars %>% 
#   dplyr::select(
#     where(
#       function(x) is.character(x) | mean(x) > 10
#     )
#   )

# mtcars %>% 
#   select(
#     where(function(x){
#       if(is.numeric(x)){
#         mean(x) > 10
#       }else{
#         is.character(x) # must return true or false
#       }
#     })
#   )
```


### Select Columns if the first value in the column is ...

```{r}
mtcars %>% 
  select(
    where(
      function(x)x[[1]] == "a"
    )
  )
```



## Filtering Rows

## Rowwise Compute new Column with subset of existing columns

```{r}
mtcars %>% 
  mutate(
    med = pmap_dbl(select(., where(is.numeric)), ~median(c(...), na.rm = T))
  )  %>% glimpse
```




## Adding column indicating if group if max value in group is in top-n max values per group

**Steps: **

1. `group_by` the grouping variable

2. summarise get the max value per group

3. `inneer_join` the result with the original data-frame

```{r}

# which of the cyl-groups  contains the two highest disp

top12 = mtcars %>%
  group_by(cyl) %>%
  summarise(m = max(disp)) %>%
  arrange(desc(m)) %>%
  ungroup() %>%
  mutate(top2 = if_else(row_number() %in% c(1,2), T, F)) %>% 
  inner_join(
    ., mtcars, by=c("cyl")
  )

```

##### example of STACKOVERFLOW

```{r}
df = structure(list(id = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 
2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 
4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 
6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 
8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9), year = c("2017", "2018", 
"2019", "2020", "2021", "2022", "2023", "2024", "2025", "2026", 
"2017", "2018", "2019", "2020", "2021", "2022", "2023", "2024", 
"2025", "2026", "2017", "2018", "2019", "2020", "2021", "2022", 
"2023", "2024", "2025", "2026", "2017", "2018", "2019", "2020", 
"2021", "2022", "2023", "2024", "2025", "2026", "2017", "2018", 
"2019", "2020", "2021", "2022", "2023", "2024", "2025", "2026", 
"2017", "2018", "2019", "2020", "2021", "2022", "2023", "2024", 
"2025", "2026", "2017", "2018", "2019", "2020", "2021", "2022", 
"2023", "2024", "2025", "2026", "2017", "2018", "2019", "2020", 
"2021", "2022", "2023", "2024", "2025", "2026", "2017", "2018", 
"2019", "2020", "2021", "2022", "2023", "2024", "2025", "2026"
), volume = c(0.0013, 0.0013, 0.0012579, 0.0011895, 0.0011421, 
0.0010842, 0.0010211, 0.0010158, 0.00099474, 0.00092632, 0.07878, 
0.078791, 0.077295, 0.076638, 0.075538, 0.074468, 0.074776, 0.074051, 
0.071706, 0.068056, 0.023269, 0.023011, 0.022374, 0.021962, 0.021408, 
0.020949, 0.020811, 0.020354, 0.019309, 0.018042, 0.0004, 0.0004, 
0.00038421, 0.00035263, 0.00033158, 0.00032105, 0.00026842, 0.00028421, 
0.00026842, 0.00024211, 0.0002, 0.0001, 0.00011579, 0, 0, 0, 
0, 0, 0, 0, 0.028422, 0.028361, 0.027768, 0.027501, 0.027029, 
0.02651, 0.026588, 0.026209, 0.025094, 0.023391, 0.0001, 0.0001, 
0, 0, 0, 0, 0, 0, 0, 0, 0.0047, 0.0047158, 0.0048368, 0.0048316, 
0.0049263, 0.0049737, 0.0049947, 0.0051684, 0.0052526, 0.0051842, 
0.0106, 0.010389, 0.010279, 0.010005, 0.0098421, 0.0096368, 0.0094053, 
0.0093368, 0.0092526, 0.0089316)), class = c("tbl_df", "tbl", 
"data.frame"), row.names = c(NA, -90L))

df %>%
  group_by(id) %>%
  summarise(m = max(volume)) %>%
  arrange(desc(m)) %>%
  mutate(top3 = if_else(row_number() %in% c(1, 2, 3), T, F)) %>%
  inner_join(., df, by = c("id")) -> top123
```


## list Columns (and `dplyr`)

- 



### ```purrr::pmap```













